// Rozszerzona highlightArea: kolor obramowania jako parametr
function highlightArea(ctx, x, y, size, color = 'blue') {
  ctx.beginPath();
  ctx.rect(x, y, size, size);
  ctx.lineWidth = 2;
  ctx.strokeStyle = color;
  ctx.stroke();
}

function detectLed(video) {
  const now = performance.now();
  const ctx = canvas.getContext('2d');

  // 1) Narysuj klatkę
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // 2) Definicja 3 pól detekcji
  const positions = [
    { x: canvas.width * 0.2 - SAMPLE_SIZE / 2, y: canvas.height / 2 - SAMPLE_SIZE / 2 },
    { x: canvas.width * 0.5 - SAMPLE_SIZE / 2, y: canvas.height / 2 - SAMPLE_SIZE / 2 },
    { x: canvas.width * 0.8 - SAMPLE_SIZE / 2, y: canvas.height / 2 - SAMPLE_SIZE / 2 }
  ];

  const hsvResults = [];
  const redDetected = [];

  // 3) Dla każdego pola oblicz HSV i zaznacz je na ekranie
  positions.forEach((pos, i) => {
    const data = ctx.getImageData(pos.x, pos.y, SAMPLE_SIZE, SAMPLE_SIZE).data;
    let sumH = 0, sumS = 0, sumV = 0;
    const pxCount = SAMPLE_SIZE * SAMPLE_SIZE;

    for (let p = 0; p < data.length; p += 4) {
      const [h, s, v] = rgbToHsv(data[p], data[p+1], data[p+2]);
      sumH += h; sumS += s; sumV += v;
    }

    const avgH = sumH / pxCount;
    const avgS = sumS / pxCount;
    const avgV = sumV / pxCount;
    hsvResults[i] = { avgH, avgS, avgV };
    redDetected[i] = isRed(avgH, avgS, avgV);

    // 4) Narysuj obramowanie kwadratu: zielone jeśli czerwony, niebieskie w przeciwnym razie
    highlightArea(
      ctx,
      pos.x, pos.y,
      SAMPLE_SIZE,
      redDetected[i] ? 'lime' : 'blue'
    );
  });

  // 5) Wyświetl logi dla wszystkich pól
  log.innerHTML = hsvResults.map((r, i) =>
    `Pole ${i+1}: H=${r.avgH.toFixed(1)}, S=${r.avgS.toFixed(2)}, V=${r.avgV.toFixed(2)}, czerwony: ${redDetected[i]}`
  ).join('<br>');

  // 6) Sekwencja na podstawie pola środkowego (index 1)
  const main = hsvResults[1];
  let currentState = lastState;

  if (lastState === 'off' && isRed(main.avgH, main.avgS, main.avgV)) {
    currentState = 'on';
  } else if (lastState === 'on' && (main.avgV < V_OFF || !isRed(main.avgH, main.avgS, main.avgV))) {
    currentState = 'off';
  }

  if (currentState !== lastState && (now - lastSwitchTime) > CHANGE_TIME) {
    const durationSec = ((now - lastSwitchTime) / 1000).toFixed(2);
    document.getElementById('czas').textContent =
      `${lastState === 'on' ? 'Włączona' : 'Wyłączona'} przez ${durationSec}s`;

    stateDurations.push({ state: lastState, duration: parseFloat(durationSec) });
    if (stateDurations.length === 1 && stateDurations[0].state === 'off') {
      stateDurations.shift();
    }

    result.textContent += (currentState === 'on' ? '-' : '/');
    if (result.textContent.length > MAX_LENGTH) {
      result.textContent = result.textContent.slice(-MAX_LENGTH);
    }

    lastState = currentState;
    lastSwitchTime = now;
    sequenceEnded = false;
  }

  // 7) Po 2 s braku zmian – koniec sekwencji
  if (!sequenceEnded && (now - lastSwitchTime) > END_SEQUENCE_TIMEOUT) {
    stateDurations.push({ state: lastState, duration: 2.0 });
    stateDurations.pop(); // usuń pauzę, jeżeli nie chcesz jej w wzorcach
    checkTemplates();
    sequenceEnded = true;
  }
}